"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Patching = exports.APPROX_DEVEL = exports.APPROX_ONLY_EMPTY = exports.APPROX_WRITE = exports.APPROX_READ = void 0;
const util_1 = require("../misc/util");
const tokens_1 = require("../analysis/tokens");
const types_1 = require("@babel/types");
const assert_1 = __importDefault(require("assert"));
const logger_1 = __importDefault(require("../misc/logger"));
const options_1 = require("../options");
const extras_1 = require("../parsing/extras");
exports.APPROX_READ = true;
exports.APPROX_WRITE = true;
exports.APPROX_ONLY_EMPTY = false;
exports.APPROX_DEVEL = false;
class Patching {
    hints;
    allocToToken = new Map();
    dynamicReads = [];
    usedHints = new Set();
    constructor(hints) {
        this.hints = hints;
        (0, assert_1.default)(!options_1.options.widening, "Option --widening is not supported with approximate interpretation patching");
        (0, assert_1.default)(!options_1.options.oldobj, "Option --oldobj is not supported with approximate interpretation patching");
    }
    registerAllocationSite(t) {
        (0, assert_1.default)(t instanceof tokens_1.AllocationSiteToken || t instanceof tokens_1.FunctionToken || t instanceof tokens_1.NativeObjectToken);
        let loc;
        if (t instanceof tokens_1.AllocationSiteToken)
            loc = (0, util_1.locationToStringWithFileAndEnd)(t.allocSite.loc, true);
        else if (t instanceof tokens_1.FunctionToken)
            loc = (0, util_1.locationToStringWithFileAndEnd)(t.fun.loc, true);
        else {
            (0, assert_1.default)(t.moduleInfo);
            loc = `${t.moduleInfo.toString()}:-1:-1:-1:-1`;
        }
        let type;
        if (t instanceof tokens_1.PrototypeToken)
            type = "Prototype";
        else if (t instanceof tokens_1.FunctionToken) {
            if ((0, types_1.isClassMethod)(t.fun) && t.fun.kind === "constructor")
                type = "Class";
            else
                type = "Function";
        }
        else if (t instanceof tokens_1.ArrayToken)
            type = "Array";
        else
            type = "Object";
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Registering token ${type}[${loc}]`);
        this.allocToToken.set(`${loc}:${type}`, t);
    }
    recordDynamicRead(node, dstVar) {
        if (!exports.APPROX_READ || !dstVar)
            return;
        this.dynamicReads.push({ node, dstVar });
    }
    getRequireHints(mod, loc) {
        if (mod !== undefined) {
            const i = this.hints.moduleIndex.get(mod);
            if (i !== undefined) {
                const hints = this.hints.requires.get(`${i}:${loc}`);
                if (hints) {
                    const s = hints.map(h => {
                        this.usedHints.add(h);
                        return h.str;
                    });
                    if (logger_1.default.isVerboseEnabled())
                        logger_1.default.verbose(`Patching dynamic require/import: ${mod}:${loc} <- [${s.join(",")}]`);
                    return s;
                }
            }
        }
        return undefined;
    }
    patch(solver) {
        const d = solver.diagnostics.patching;
        d.totalHints = (0, util_1.mapArraySize)(this.hints.reads) + (0, util_1.mapArraySize)(this.hints.writes) + (0, util_1.mapArraySize)(this.hints.requires) + (0, util_1.mapArraySize)(this.hints.evals);
        d.modulesNotAnalyzed = 0;
        const mods = new Set(Array.from(solver.globalState.moduleInfos.values()).filter(m => m.node));
        const fileToModule = this.hints.modules.map(m => {
            const mod = solver.globalState.moduleInfos.get(m);
            if (!mod) {
                if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                    logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Module has been analyzed dynamically but not statically: ${m} (possibly excluded from analysis)`);
                d.modulesNotAnalyzed++;
            }
            else
                mods.delete(mod);
            if (mod && !mod.node)
                return undefined;
            return mod?.toString();
        });
        if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
            for (const m of mods)
                logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Module analyzed statically but not dynamically: ${m}`);
        d.modulesNotInHints = mods.size;
        const canonicalizeDynamicLocation = (loc) => {
            const i = loc.indexOf(":");
            if (i === -1)
                assert_1.default.fail(`Unable to parse location: ${loc}`);
            const file = fileToModule[parseInt(loc)];
            if (file !== undefined)
                return `${file}:${loc.substring(i + 1)}`;
            else
                return undefined;
        };
        const visitedFunctions = new Set();
        for (const fun of this.hints.functions) {
            const loc = canonicalizeDynamicLocation(fun);
            if (loc)
                visitedFunctions.add(loc);
        }
        d.functionsNotVisited = 0;
        function checkFunctionVisited(fun) {
            if (!visitedFunctions.has((0, util_1.locationToStringWithFileAndEnd)(fun.node.loc, true)) &&
                !(0, extras_1.isDummyConstructor)(fun.node)) {
                if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                    logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Function analyzed statically but not dynamically: ${fun}`);
                d.functionsNotVisited++;
            }
            for (const fun2 of fun.functions)
                checkFunctionVisited(fun2);
        }
        for (const mod of solver.globalState.moduleInfos.values())
            for (const fun of mod.functions)
                checkFunctionVisited(fun);
        const patch = (dstVar, valToken, hint) => {
            if (options_1.options.diagnostics)
                this.usedHints.add(hint);
            const repVar = solver.fragmentState.getRepresentative(dstVar);
            if (!solver.fragmentState.hasToken(repVar, valToken) &&
                (!exports.APPROX_ONLY_EMPTY || solver.fragmentState.getTokensSize(repVar)[0] === 0)) {
                solver.addToken(valToken, repVar);
                return true;
            }
            return false;
        };
        if (exports.APPROX_READ) {
            const locationToHints = new Map();
            for (const hs of this.hints.reads.values())
                for (const hint of hs) {
                    const dl = canonicalizeDynamicLocation(hint.loc);
                    if (dl !== undefined)
                        (0, util_1.mapArrayAdd)(dl, hint, locationToHints);
                }
            for (const { node, dstVar } of this.dynamicReads) {
                const nodeLoc = (0, util_1.locationToStringWithFileAndEnd)(node.loc, true);
                const hints = locationToHints.get(nodeLoc);
                if (hints)
                    for (const hint of hints) {
                        const valLoc = canonicalizeDynamicLocation(hint.valLoc);
                        if (valLoc !== undefined) {
                            const valToken = this.allocToToken.get(`${valLoc}:${hint.valType}`);
                            if (!valToken) {
                                if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                                    logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Token not found: ${hint.valType}[${valLoc}] for value at read`);
                                d.tokensNotFound++;
                                continue;
                            }
                            if (logger_1.default.isVerboseEnabled())
                                logger_1.default.verbose(`Patching dynamic read: ${dstVar} <- ${valToken}`);
                            if (patch(dstVar, valToken, hint)) {
                                d.readTokensAdded++;
                                if (solver.fragmentState.unhandledDynamicPropertyReads.has(node)) {
                                    solver.fragmentState.unhandledDynamicPropertyReads.delete(node);
                                    d.patchedReads++;
                                }
                            }
                        }
                    }
            }
        }
        if (exports.APPROX_WRITE) {
            const nodes = new Map();
            for (const node of solver.fragmentState.unhandledDynamicPropertyWrites.keys()) {
                const nodeLoc = (0, util_1.locationToStringWithFileAndEnd)(node.loc, true);
                (0, util_1.mapArrayAdd)(nodeLoc, node, nodes);
            }
            for (const hs of this.hints.writes.values())
                for (const hint of hs) {
                    const baseLoc = hint.baseLoc ? canonicalizeDynamicLocation(hint.baseLoc) : undefined;
                    const valLoc = hint.valLoc ? canonicalizeDynamicLocation(hint.valLoc) : undefined;
                    if (baseLoc !== undefined && valLoc !== undefined) {
                        const baseToken = this.allocToToken.get(`${baseLoc}:${hint.baseType}`);
                        if (!baseToken) {
                            if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                                logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Token not found: ${hint.baseType}[${baseLoc}] for base at write`);
                            d.tokensNotFound++;
                            continue;
                        }
                        const valToken = this.allocToToken.get(`${valLoc}:${hint.valType}`);
                        if (!valToken) {
                            if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                                logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Token not found: ${hint.valType}[${valLoc}] for value at write`);
                            d.tokensNotFound++;
                            continue;
                        }
                        const dstVar = solver.varProducer.objPropVar(baseToken, hint.prop, hint.type);
                        if (logger_1.default.isVerboseEnabled())
                            logger_1.default.verbose(`Patching dynamic write: ${dstVar.obj}["${hint.prop}"] <- ${valToken}`);
                        if (patch(dstVar, valToken, hint)) {
                            d.writeTokensAdded++;
                            const hintLoc = canonicalizeDynamicLocation(hint.loc);
                            if (hintLoc) {
                                const ns = nodes.get(hintLoc);
                                if (ns)
                                    for (const node of ns)
                                        if (solver.fragmentState.unhandledDynamicPropertyWrites.has(node)) {
                                            solver.fragmentState.unhandledDynamicPropertyWrites.delete(node);
                                            d.patchedWrites++;
                                        }
                            }
                        }
                    }
                }
        }
        if (options_1.options.diagnostics) {
            for (const hs of this.hints.reads.values())
                for (const hint of hs)
                    if (!this.usedHints.has(hint)) {
                        const loc = canonicalizeDynamicLocation(hint.loc);
                        const valLoc = canonicalizeDynamicLocation(hint.valLoc);
                        if (loc && valLoc) {
                            if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                                logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Unused read hint: ${loc} <- ${valLoc}:${hint.valType}[${hint.prop ? `"${hint.prop}"` : "?"}]`);
                            d.unusedHints++;
                        }
                    }
            for (const hs of this.hints.writes.values())
                for (const hint of hs)
                    if (!this.usedHints.has(hint)) {
                        const baseLoc = canonicalizeDynamicLocation(hint.baseLoc);
                        const valLoc = canonicalizeDynamicLocation(hint.valLoc);
                        if (baseLoc && valLoc) {
                            if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                                logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Unused write hint: ${baseLoc}:${hint.baseType}["${hint.prop}"] <- ${valLoc}:${hint.valType}`);
                            d.unusedHints++;
                        }
                    }
            for (const hs of this.hints.requires.values())
                for (const hint of hs)
                    if (!this.usedHints.has(hint)) {
                        const loc = canonicalizeDynamicLocation(hint.loc);
                        if (loc) {
                            if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                                logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Unused require hint: ${loc} "${hint.str}"`);
                            d.unusedHints++;
                        }
                    }
            for (const hs of this.hints.evals.values())
                for (const hint of hs)
                    if (!this.usedHints.has(hint)) {
                        const loc = canonicalizeDynamicLocation(hint.loc);
                        if (loc) {
                            if (logger_1.default.isVerboseEnabled() || exports.APPROX_DEVEL)
                                logger_1.default[exports.APPROX_DEVEL ? "warn" : "verbose"](`Unused eval hint: ${loc} "${hint.str.substring(0, 40).replaceAll("\n", "\u2424")}${hint.str.length > 40 ? "..." : ""}"`);
                            d.unusedHints++;
                        }
                    }
        }
    }
    printDiagnostics(solver) {
        const p = solver.diagnostics.patching;
        logger_1.default.info(`Patching tokens added: ${p.readTokensAdded} reads, ${p.writeTokensAdded} writes`);
        logger_1.default.info(`Dynamic reads patched: ${p.patchedReads}, remaining unpatched: ${solver.fragmentState.unhandledDynamicPropertyReads.size}`);
        logger_1.default.info(`Dynamic writes patched: ${p.patchedWrites}, remaining unpatched: ${solver.fragmentState.unhandledDynamicPropertyWrites.size}`);
        logger_1.default.info(`Modules analyzed statically but not dynamically: ${p.modulesNotInHints}, dynamically but not statically: ${p.modulesNotAnalyzed}`);
        logger_1.default.info(`Functions analyzed statically but not dynamically: ${p.functionsNotVisited}/${solver.globalState.functionInfos.size}`);
        logger_1.default.info(`Tokens not found: ${p.tokensNotFound}`);
        logger_1.default.info(`Unused hints: ${p.unusedHints}/${p.totalHints}`);
    }
}
exports.Patching = Patching;
//# sourceMappingURL=patching.js.map