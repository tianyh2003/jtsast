"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessManager = void 0;
const child_process_1 = require("child_process");
const logger_1 = __importDefault(require("../misc/logger"));
const options_1 = require("../options");
const util_1 = require("../misc/util");
const fs_1 = require("fs");
const transform_1 = require("./transform");
const globalstate_1 = require("../analysis/globalstate");
const hints_1 = require("./hints");
const timer_1 = __importDefault(require("../misc/timer"));
const path_1 = require("path");
const files_1 = require("../misc/files");
class ProcessManager {
    a;
    p;
    hints = new hints_1.Hints();
    numExecutions = 0;
    numForced = 0;
    numForcedExceptions = 0;
    numModuleExceptions = 0;
    numStaticFunctions = 0;
    staticRequires = new Map();
    approxTime = 0;
    totalCodeSize = 0;
    resultPromiseResolve;
    timer;
    constructor(a = new globalstate_1.GlobalState) {
        this.a = a;
        (0, options_1.resolveBaseDir)();
        logger_1.default.verbose("Starting approximate interpretation process");
        const resolvedDirname = __dirname.endsWith(".js") ? __dirname : `${__dirname}/../../lib/approx`;
        this.p = (0, child_process_1.fork)(`${resolvedDirname}/approx.js`, [JSON.stringify(options_1.options)], { stdio: "inherit" });
        this.p.on('message', (msg) => {
            if (!this.resultPromiseResolve) {
                logger_1.default.error("Unexpected message from child process");
                return;
            }
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Hints received from approximate interpretation process:\n${JSON.stringify(msg, undefined, 2)}`);
            this.add(msg.hints);
            this.numForced += msg.numForced;
            this.numForcedExceptions += msg.numForcedExceptions;
            this.numModuleExceptions += msg.moduleException ? 1 : 0;
            this.numStaticFunctions += msg.numStaticFunctions;
            (0, util_1.addPairArrayToMapSet)(msg.staticRequires, this.staticRequires);
            this.totalCodeSize = msg.totalCodeSize;
            this.resultPromiseResolve();
            this.resultPromiseResolve = undefined;
            this.approxTime += this.timer.elapsed();
            this.timer = undefined;
        });
    }
    async analyzeFiles(files) {
        for (const file of files)
            this.a.reachedFile((0, path_1.resolve)(options_1.options.basedir, file));
        while (this.a.pendingFiles.length > 0) {
            const file = this.a.pendingFiles.shift();
            const m = this.a.getModuleInfo(file);
            if (this.hints.moduleIndex.has(m.toString())) {
                if (logger_1.default.isDebugEnabled())
                    logger_1.default.debug(`Skipping ${file}, module already visited`);
            }
            else if (!([".js", ".jsx", ".es", ".mjs", ".cjs", ".ts", ".tsx", ".mts", ".cts"].includes((0, path_1.extname)(file)) ||
                ((0, path_1.extname)(file) === "" && (0, files_1.isShebang)(file)))) {
                logger_1.default.info(`Skipping ${file}, unsupported extension`);
            }
            else {
                if (options_1.options.printProgress)
                    logger_1.default.info(`Analyzing ${file}`);
                this.numExecutions++;
                await this.execute(file);
            }
            const rs = this.staticRequires.get(file);
            if (rs)
                for (const r of rs)
                    try {
                        const filepath = (0, files_1.requireResolve)(r, file, this.a);
                        if (filepath)
                            this.a.reachedFile(filepath, m);
                    }
                    catch {
                        logger_1.default.warn(`Unable to resolve module '${r}' from ${file}`);
                    }
        }
    }
    stop() {
        logger_1.default.verbose("Stopping approximate interpretation process");
        this.p.kill();
    }
    async execute(file) {
        (0, transform_1.checkFile)(file);
        this.timer = new timer_1.default();
        return new Promise((resolve) => {
            this.resultPromiseResolve = resolve;
            this.p.send({ file });
        });
    }
    add(newHints) {
        const moduleReindex = new Map();
        for (const [i, s] of newHints.modules.entries()) {
            let m;
            if (s[0] === "/") {
                const i = s.indexOf(":eval["), file = i === -1 ? s : s.substring(0, i), rest = i === -1 ? "" : s.substring(i);
                const mod = this.a.reachedFile(file);
                m = mod.toString() + rest;
            }
            else
                m = s;
            moduleReindex.set(i, this.hints.addModule(m));
        }
        const convert = (loc) => `${moduleReindex.get(parseInt(loc))}${loc.substring(loc.indexOf(":"))}`;
        for (const f of newHints.functions)
            this.hints.addFunction(convert(f));
        for (const { loc, prop, valLoc, valType } of newHints.reads) {
            this.hints.addReadHint({
                loc: convert(loc),
                prop,
                valLoc: convert(valLoc),
                valType
            });
        }
        for (const { type, loc, baseLoc, baseType, prop, valLoc, valType } of newHints.writes) {
            this.hints.addWriteHint({
                type,
                loc: convert(loc),
                baseLoc: convert(baseLoc),
                baseType,
                prop,
                valLoc: convert(valLoc),
                valType
            });
        }
        for (const { loc, str } of newHints.requires)
            this.hints.addRequireHint({
                loc: convert(loc),
                str
            });
        for (const { loc, str } of newHints.evals)
            this.hints.addEvalHint({
                loc: convert(loc),
                str
            });
    }
    saveHintsToFile(file) {
        const fd = (0, fs_1.openSync)(file, "w");
        (0, files_1.writeStreamedStringify)(this.hints.toJSON(), fd);
        (0, fs_1.closeSync)(fd);
        logger_1.default.info(`Approximate interpretation hints written to ${file}`);
    }
    printDiagnostics() {
        const staticFunctionsVisited = this.getStaticFunctionsVisited();
        logger_1.default.info(`Approximate interpretation time: ${this.approxTime}ms, packages visited: ${this.a.packageInfos.size}, code size: ${Math.ceil(this.totalCodeSize / 1024)}KB`);
        logger_1.default.info(`Modules analyzed dynamically: ${this.numExecutions}, visited: ${this.a.moduleInfos.size}, exceptions: ${this.numModuleExceptions}`);
        logger_1.default.info(`Force-executed functions: ${this.numForced}/${this.numStaticFunctions}, ` +
            `visited: ${staticFunctionsVisited}${this.numStaticFunctions > 0 ? ` (${(0, util_1.percent)(staticFunctionsVisited / this.numStaticFunctions)})` : ""}, ` +
            `exceptions: ${this.numForcedExceptions}`);
        logger_1.default.info(`Produced hints reads: ${(0, util_1.mapArraySize)(this.hints.reads)}, writes: ${(0, util_1.mapArraySize)(this.hints.writes)}, ` +
            `requires: ${(0, util_1.mapArraySize)(this.hints.requires)}, evals: ${(0, util_1.mapArraySize)(this.hints.evals)}`);
    }
    getDiagnostics() {
        return {
            time: this.approxTime,
            visitedPackages: this.a.packageInfos.size,
            codeSize: Math.ceil(this.totalCodeSize / 1024),
            modulesAnalyzed: this.numExecutions,
            modulesVisited: this.a.moduleInfos.size,
            moduleExceptions: this.numModuleExceptions,
            forceExecutedFunctions: this.numForced,
            staticFunctions: this.numStaticFunctions,
            staticFunctionsVisited: this.getStaticFunctionsVisited(),
            exceptions: this.numModuleExceptions,
            readHints: (0, util_1.mapArraySize)(this.hints.reads),
            writeHints: (0, util_1.mapArraySize)(this.hints.writes),
            requireHints: (0, util_1.mapArraySize)(this.hints.requires),
            evalHints: (0, util_1.mapArraySize)(this.hints.evals)
        };
    }
    getStaticFunctionsVisited() {
        let c = 0;
        for (const f of this.hints.functions) {
            const i = parseInt(f);
            if (!this.hints.modules[i].endsWith("]"))
                c++;
        }
        return c;
    }
    saveDiagnosticsToFile(file) {
        const fd = (0, fs_1.openSync)(file, "w");
        (0, fs_1.writeSync)(fd, JSON.stringify(this.getDiagnostics(), undefined, 2));
        (0, fs_1.closeSync)(fd);
        logger_1.default.info(`Approximate interpretation diagnostics written to ${file}`);
    }
}
exports.ProcessManager = ProcessManager;
//# sourceMappingURL=processmanager.js.map