"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.approxTransform = exports.checkFile = exports.SPECIALS = exports.PREFIX = void 0;
const core_1 = require("@babel/core");
const types_1 = require("@babel/types");
const logger_1 = __importDefault(require("../misc/logger"));
const util_1 = require("../misc/util");
const path_1 = require("path");
const module_1 = __importDefault(require("module"));
const assert_1 = __importDefault(require("assert"));
exports.PREFIX = "_J$";
exports.SPECIALS = new Set(["start", "pw", "dpr", "alloc", "init", "method", "comp", "new", "enter", "catch", "loop", "eval", "cr"]
    .map(s => exports.PREFIX + s));
const START_CJS = core_1.template.statements(`const ${exports.PREFIX}mod = MODULE; module = ${exports.PREFIX}start(${exports.PREFIX}mod, typeof module !== 'undefined' && module); Object.freeze(require.extensions)`);
const START_ESM = core_1.template.statements(`const ${exports.PREFIX}mod = MODULE; ${exports.PREFIX}start(${exports.PREFIX}mod); ` +
    `import {createRequire as ${exports.PREFIX}cr} from 'node:module'; ` +
    `import {dirname as ${exports.PREFIX}dirname} from 'node:path';` +
    `var require = ${exports.PREFIX}cr(import.meta.url), module = ${exports.PREFIX}proxy, exports = ${exports.PREFIX}proxy, ` +
    `__filename = import.meta.url.startsWith("file://") ? import.meta.url.substring(7) : undefined, ` +
    `__dirname = import.meta.url.startsWith("file://") ? ${exports.PREFIX}dirname(import.meta.url.substring(7)) : undefined;`);
const OBJCLS = core_1.template.expression(`(${exports.PREFIX}init(), ${exports.PREFIX}alloc(${exports.PREFIX}mod, LOC, BODY, true, CLS))`);
const FUNARRAY = core_1.template.expression(`${exports.PREFIX}alloc(${exports.PREFIX}mod, LOC, BODY)`);
const FUNDECL = core_1.template.statement(`${exports.PREFIX}alloc(${exports.PREFIX}mod, LOC, VAL)`);
const INIT = core_1.template.statement(`${exports.PREFIX}init()`);
const ALLOC = core_1.template.statements(`${exports.PREFIX}alloc(${exports.PREFIX}mod, LOC, VAL, true, true)`);
const PW = core_1.template.expression(`${exports.PREFIX}pw(${exports.PREFIX}mod, LOC, BASE, PROP, VAL, DYN)`);
const DPR = core_1.template.expression(`${exports.PREFIX}dpr(${exports.PREFIX}mod, LOC, BASE, PROP)`);
const NEW = core_1.template.expression(`${exports.PREFIX}new(${exports.PREFIX}mod, LOC, FUN, ARGS)`);
const FUNCALL = core_1.template.expression(`${exports.PREFIX}fun(${exports.PREFIX}mod, LOC, FUN, OPTCALL, ARGS)`);
const EVAL = core_1.template.expression(`${exports.PREFIX}eval(${exports.PREFIX}mod, LOC, STR)`);
const REQUIRE = core_1.template.expression(`${exports.PREFIX}require(${exports.PREFIX}mod, LOC, STR)`);
const METHODCALL = core_1.template.expression(`${exports.PREFIX}method(${exports.PREFIX}mod, LOC, BASE, PROP, DYN, OPTMEMBER, OPTCALL, ARGS)`);
const COMP = core_1.template.expression(`${exports.PREFIX}comp(${exports.PREFIX}mod, LOC, BODY, KIND, STATIC, DYN)`);
const ENTER = core_1.template.expression(`${exports.PREFIX}enter(${exports.PREFIX}mod, LOC)`);
const SUPER = core_1.template.expression(`${exports.PREFIX}this(${exports.PREFIX}mod, LOC, SUPER)`);
const THIS = core_1.template.expression(`${exports.PREFIX}this(${exports.PREFIX}mod, LOC, NEWTARGET)`);
const CATCH = core_1.template.statement(`${exports.PREFIX}catch(ID)`);
const LOOP = core_1.template.statement(`{${exports.PREFIX}loop();BODY}`);
const JELLY_HOME = (0, path_1.dirname)((0, path_1.dirname)(__dirname));
function checkFile(file) {
    if (file.startsWith((0, path_1.resolve)(JELLY_HOME, "node_modules")) || file.startsWith((0, path_1.resolve)(JELLY_HOME, "lib")))
        throw new Error(`Error: Cannot analyze Jelly runtime file ${file}`);
}
exports.checkFile = checkFile;
function approxTransform(ast, str, file, mode) {
    let numStaticFunctions = 0;
    const staticRequires = new Set();
    const t = (0, core_1.transformFromAstSync)(ast, str, {
        plugins: [
            transform
        ],
        cwd: __dirname,
        configFile: false,
        compact: str.length > 1048576,
        code: true
    });
    if (t?.code) {
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug("Transformed for approximate interpretation:\n" + t.code);
        return { transformed: t.code, staticRequires, numStaticFunctions };
    }
    else {
        logger_1.default.error(`Error: Transformation failed for ${file}`);
        return { transformed: undefined, staticRequires, numStaticFunctions };
    }
    function transform() {
        return {
            visitor: {
                Program: {
                    exit(path) {
                        visitProgram(path, file);
                    }
                },
                ObjectExpression: {
                    exit(path) {
                        visitObjectOrClassExpression(path);
                    }
                },
                ArrayExpression: {
                    exit(path) {
                        visitFunctionOrArrayExpression(path);
                    }
                },
                ClassExpression: {
                    exit(path) {
                        visitClass(path);
                        visitObjectOrClassExpression(path);
                    }
                },
                FunctionExpression: {
                    exit(path) {
                        visitFunction(path);
                        visitFunctionOrArrayExpression(path);
                    }
                },
                ArrowFunctionExpression: {
                    exit(path) {
                        visitFunction(path);
                        visitFunctionOrArrayExpression(path);
                    }
                },
                FunctionDeclaration: {
                    exit(path) {
                        visitFunction(path);
                        if (path.node.id)
                            visitFunctionDeclaration(path, path.node.id.name);
                    }
                },
                ClassDeclaration: {
                    exit(path) {
                        visitClass(path);
                        if (path.node.id)
                            visitClassDeclaration(path, path.node.id.name);
                    }
                },
                AssignmentExpression: {
                    exit(path) {
                        if (((0, types_1.isMemberExpression)(path.node.left) || (0, types_1.isOptionalMemberExpression)(path.node.left)) &&
                            !(0, types_1.isPrivateName)(path.node.left.property) && !(0, types_1.isSuper)(path.node.left.object))
                            visitPropertyWrite(path, path.node.left.object, path.node.left.property, path.node.right, path.node.left.computed);
                    }
                },
                MemberExpression: {
                    exit(path) {
                        visitPropertyRead(path);
                    }
                },
                OptionalMemberExpression: {
                    exit(path) {
                        visitPropertyRead(path);
                    }
                },
                CallExpression: {
                    exit(path) {
                        if ((0, types_1.isImport)(path.node.callee) && path.node.arguments.length >= 1)
                            visitRequireOrImport(path);
                        else if ((0, types_1.isSuper)(path.node.callee))
                            visitSuperCall(path);
                        else
                            visitCall(path);
                    }
                },
                OptionalCallExpression: {
                    exit(path) {
                        visitCall(path);
                    }
                },
                NewExpression: {
                    exit(path) {
                        visitNew(path);
                    }
                },
                ObjectProperty: {
                    exit(path) {
                        if ((0, types_1.isObjectExpression)(path.parent) && !(0, types_1.isPrivateName)(path.node.key))
                            visitPropertyOrMethod(path);
                    }
                },
                ObjectMethod: {
                    exit(path) {
                        visitFunction(path);
                        visitPropertyOrMethod(path);
                    }
                },
                ClassProperty: {
                    exit(path) {
                        visitPropertyOrMethod(path);
                    }
                },
                ClassMethod: {
                    exit(path) {
                        visitFunction(path);
                        if (path.node.kind !== "constructor")
                            visitPropertyOrMethod(path);
                    }
                },
                ClassPrivateMethod: {
                    exit(path) {
                        visitFunction(path);
                    }
                },
                CatchClause: {
                    exit(path) {
                        visitCatch(path);
                    }
                },
                Loop: {
                    exit(path) {
                        visitLoop(path);
                    }
                },
                ObjectPattern: {},
            }
        };
    }
    function getLoc(loc) {
        return (0, types_1.stringLiteral)((0, util_1.locationToString)(loc, false, true));
    }
    function visitProgram(path, file) {
        path.scope.registerDeclaration(path.unshiftContainer("body", (mode === "commonjs" ? START_CJS : START_ESM)({
            MODULE: (0, types_1.stringLiteral)(file)
        }))[0]);
    }
    function visitObjectOrClassExpression(path) {
        path.replaceWith(OBJCLS({
            LOC: getLoc(path.node.loc),
            BODY: path.node,
            CLS: (0, types_1.booleanLiteral)((0, types_1.isClassExpression)(path.node))
        }));
        path.skip();
    }
    function visitFunctionOrArrayExpression(path) {
        path.replaceWith(FUNARRAY({
            LOC: getLoc(path.node.loc),
            BODY: path.node
        }));
        path.skip();
    }
    function visitFunctionDeclaration(path, id) {
        ((0, types_1.isExportDefaultDeclaration)(path.parent) ? path.parentPath.getSibling(0) : path.getSibling(0)).insertBefore(FUNDECL({
            LOC: getLoc(path.node.loc),
            VAL: (0, types_1.identifier)(id)
        }));
    }
    function visitClass(path) {
        for (const m of path.node.body.body)
            if ((0, types_1.isClassMethod)(m) && m.kind === "constructor")
                return;
        numStaticFunctions++;
    }
    function visitClassDeclaration(path, id) {
        const p = (0, types_1.isExportDeclaration)(path.parent) ? path.parentPath : path;
        p.insertBefore(INIT());
        p.insertAfter(ALLOC({
            LOC: getLoc(path.node.loc),
            VAL: (0, types_1.identifier)(id)
        }));
    }
    function visitPropertyWrite(path, base, prop, val, isDynamic) {
        path.replaceWith(PW({
            LOC: getLoc(path.node.loc),
            BASE: base,
            PROP: isDynamic ? prop : (0, types_1.stringLiteral)(prop.name),
            VAL: val,
            DYN: (0, types_1.booleanLiteral)(isDynamic)
        }));
        path.skip();
    }
    function visitPropertyRead(path) {
        if (path.node.computed && !(0, types_1.isPrivateName)(path.node.property) && !(0, types_1.isSuper)(path.node.object) &&
            !((0, types_1.isAssignmentExpression)(path.parent) && path.parent.left === path.node))
            visitDynamicPropertyRead(path, path.node.object, path.node.property);
    }
    function visitDynamicPropertyRead(path, base, prop) {
        path.replaceWith(DPR({
            LOC: getLoc(path.node.loc),
            BASE: base,
            PROP: prop
        }));
        path.skip();
    }
    function visitCall(path) {
        if ((0, types_1.isMemberExpression)(path.node.callee) || (0, types_1.isOptionalMemberExpression)(path.node.callee)) {
            if (!(0, types_1.isPrivateName)(path.node.callee.property) && !(0, types_1.isSuper)(path.node.callee.object))
                visitMethodCall(path, path.node.callee.object, path.node.callee.property, Boolean(path.node.callee.computed), Boolean(path.node.callee.optional));
        }
        else if ((0, types_1.isExpression)(path.node.callee))
            visitFunctionCall(path);
    }
    function visitNew(path) {
        path.replaceWith(NEW({
            LOC: getLoc(path.node.loc),
            FUN: path.node.callee,
            ARGS: path.node.arguments
        }));
        path.skip();
    }
    function visitFunctionCall(path) {
        const fun = path.node.callee;
        if ((0, types_1.isIdentifier)(fun)) {
            if (exports.SPECIALS.has(fun.name))
                return;
            if (fun.name === "eval" && !path.scope.getBinding(fun.name) && !path.node.optional) {
                if (path.node.arguments.length >= 1)
                    path.get("arguments")[0].replaceWith(EVAL({
                        LOC: getLoc(path.node.loc),
                        STR: path.node.arguments[0]
                    }));
                return;
            }
            if (fun.name === "require" && !path.scope.getBinding(fun.name) && path.node.arguments.length >= 1)
                visitRequireOrImport(path);
        }
        path.replaceWith(FUNCALL({
            LOC: getLoc(path.node.loc),
            FUN: fun,
            OPTCALL: (0, types_1.booleanLiteral)(Boolean(path.node.optional)),
            ARGS: path.node.arguments
        }));
        path.skip();
    }
    function visitMethodCall(path, base, prop, isDynamic, isOptMember) {
        path.replaceWith(METHODCALL({
            LOC: getLoc(path.node.loc),
            BASE: base,
            PROP: isDynamic ? prop : (0, types_1.stringLiteral)(prop.name),
            DYN: (0, types_1.booleanLiteral)(isDynamic),
            OPTMEMBER: (0, types_1.booleanLiteral)(isOptMember),
            OPTCALL: (0, types_1.booleanLiteral)(Boolean(path.node.optional)),
            ARGS: path.node.arguments
        }));
        path.skip();
    }
    function visitSuperCall(path) {
        const constr = path.findParent(p => (0, types_1.isClassMethod)(p.node) && p.node.kind === "constructor");
        (0, assert_1.default)(constr);
        path.replaceWith(SUPER({
            LOC: getLoc(constr.node.loc),
            SUPER: path.node
        }));
        path.skip();
    }
    function visitPropertyOrMethod(path) {
        const computed = path.node.computed;
        if (!computed) {
            path.node.computed = true;
            if ((0, types_1.isIdentifier)(path.node.key))
                path.node.key = (0, types_1.stringLiteral)(path.node.key.name);
        }
        path.get("key").replaceWith(COMP({
            LOC: getLoc(path.node.loc),
            BODY: path.node.key,
            KIND: (0, types_1.stringLiteral)((0, types_1.isObjectMethod)(path.node) || (0, types_1.isClassMethod)(path.node) ? path.node.kind : "field"),
            STATIC: (0, types_1.booleanLiteral)((0, types_1.isClassMethod)(path.node) || (0, types_1.isClassProperty)(path.node) ? path.node.static : false),
            DYN: (0, types_1.booleanLiteral)(computed)
        }));
        path.skip();
    }
    function visitFunction(path) {
        numStaticFunctions++;
        const isConstructor = (0, types_1.isClassMethod)(path.node) && path.node.kind === "constructor";
        const loc = isConstructor ? path.parentPath.parent.loc : path.node.loc;
        const e = ENTER({
            LOC: getLoc(loc)
        });
        if ((0, types_1.isArrowFunctionExpression)(path.node) && !(0, types_1.isBlockStatement)(path.node.body))
            path.get("body").replaceWith((0, types_1.blockStatement)([(0, types_1.expressionStatement)(e), (0, types_1.returnStatement)(path.node.body)]));
        else {
            const body = path.node.body.body;
            if ((!isConstructor || !path.parentPath?.parent?.superClass) && !(0, types_1.isArrowFunctionExpression)(path.node))
                body.unshift((0, types_1.expressionStatement)(THIS({
                    LOC: getLoc(loc),
                    NEWTARGET: (0, types_1.conditionalExpression)((0, types_1.memberExpression)((0, types_1.identifier)("new"), (0, types_1.identifier)("target")), (0, types_1.thisExpression)(), (0, types_1.nullLiteral)())
                })));
            body.unshift((0, types_1.expressionStatement)(e));
        }
    }
    function visitCatch(path) {
        let p;
        if ((0, types_1.isIdentifier)(path.node.param))
            p = path.node.param;
        else {
            p = path.scope.generateUidIdentifier();
            if ((0, types_1.isArrayPattern)(path.node.param) || (0, types_1.isObjectPattern)(path.node.param))
                path.get("body").unshiftContainer("body", (0, types_1.variableDeclaration)("const", [(0, types_1.variableDeclarator)(path.node.param, (0, types_1.identifier)(p.name))]));
            path.node.param = p;
        }
        path.get("body").unshiftContainer("body", CATCH({
            ID: (0, types_1.identifier)(p.name)
        }));
    }
    function visitLoop(path) {
        path.get("body").replaceWith(LOOP({
            BODY: path.node.body
        }));
    }
    function visitRequireOrImport(path) {
        const arg = path.node.arguments[0];
        if ((0, types_1.isStringLiteral)(arg) && !module_1.default.isBuiltin(arg.value))
            staticRequires?.add(arg.value);
        else {
            path.get("arguments")[0].replaceWith(REQUIRE({
                LOC: getLoc(path.node.loc),
                STR: arg
            }));
            path.skip();
        }
    }
}
exports.approxTransform = approxTransform;
//# sourceMappingURL=transform.js.map