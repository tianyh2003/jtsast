"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.finalizeCallEdges = void 0;
const logger_1 = require("../misc/logger");
const timer_1 = __importDefault(require("../misc/timer"));
const assert_1 = __importDefault(require("assert"));
const tokens_1 = require("./tokens");
const util_1 = require("../misc/util");
const constraintvars_1 = require("./constraintvars");
function finalizeCallEdges(solver) {
    (0, logger_1.writeStdOutIfActive)("Finalizing...");
    const finalTimer = new timer_1.default;
    const f = solver.fragmentState;
    const a = solver.globalState;
    if (solver.diagnostics.aborted || solver.diagnostics.timeout) {
        for (const n of f.callLocations) {
            const caller = f.callToContainingFunction.get(n);
            (0, assert_1.default)(caller);
            const vs = f.callToCalleeVars.get(n);
            if (vs)
                for (const v of vs) {
                    const vRep = f.getRepresentative(v);
                    for (const t of f.getTokens(vRep))
                        if (t instanceof tokens_1.FunctionToken)
                            f.registerCallEdge(n, caller, a.functionInfos.get(t.fun));
                }
        }
    }
    const pm = new Map();
    for (const { base, prop, node, enclosing } of f.propertyReads)
        (0, util_1.mapGetArray)((0, util_1.mapGetMap)(pm, f.getRepresentative(base)), prop).push([node, enclosing]);
    const tm = new Map();
    for (const [base, ms] of pm)
        for (const t1 of f.getTokens(base)) {
            if ((0, constraintvars_1.isObjectPropertyVarObj)(t1)) {
                (0, util_1.mapGetSet)(tm, t1).add(ms);
                for (const t2 of f.getTokens(f.getRepresentative(f.varProducer.ancestorsVar(t1))))
                    if ((0, constraintvars_1.isObjectPropertyVarObj)(t2))
                        (0, util_1.mapGetSet)(tm, t2).add(ms);
            }
        }
    const getters = new Map();
    const collectGetters = (v) => {
        if (v instanceof constraintvars_1.ObjectPropertyVar && v.accessor === "get")
            (0, util_1.mapGetMap)(getters, v.obj).set(v.prop, v);
    };
    for (const v of f.vars)
        collectGetters(v);
    for (const v of f.redirections.keys())
        collectGetters(v);
    for (const [t, qs] of tm)
        for (const ms of qs) {
            const gs = getters.get(t);
            if (gs)
                for (const [prop, targets] of ms) {
                    const v = gs.get(prop);
                    if (v) {
                        const ts = f.getTokens(f.getRepresentative(v));
                        for (const t3 of ts)
                            if (t3 instanceof tokens_1.FunctionToken && t3.fun.params.length === 0)
                                for (const [node, enclosing] of targets) {
                                    f.registerCall(node, enclosing, undefined, { accessor: true });
                                    f.registerCallEdge(node, enclosing, a.functionInfos.get(t3.fun), { accessor: true });
                                }
                    }
                }
        }
    solver.diagnostics.finalizationTime = finalTimer.elapsed();
}
exports.finalizeCallEdges = finalizeCallEdges;
//# sourceMappingURL=finalization.js.map