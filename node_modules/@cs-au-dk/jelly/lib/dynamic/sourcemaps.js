"use strict";
/*! DO NOT INSTRUMENT */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractCodeSnippet = exports.getSourceObject = exports.decodeAndSetSourceMap = exports.mapToOriginalLocation = void 0;
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const node_module_1 = require("node:module");
const SOURCE_FILE_MAP = new Map();
function locIsValid(src) {
    (0, assert_1.default)(src, `startLoc is null`);
    (0, assert_1.default)(src.hasOwnProperty("originalLine"), `loc is null`);
    (0, assert_1.default)(src.hasOwnProperty("originalColumn"), `loc is null`);
}
function mapToOriginalLocation(sourceMap, memoryLocation) {
    const startLoc = sourceMap.findEntry(memoryLocation.start.line - 1, memoryLocation.start.column - 1);
    locIsValid(startLoc);
    const startLine = startLoc.originalLine + 1;
    const startColumn = startLoc.originalColumn + 1;
    (0, assert_1.default)(!Number.isNaN(startLine), `startLoc is null`);
    (0, assert_1.default)(!Number.isNaN(startColumn), `startLoc is null`);
    const endLoc = sourceMap.findEntry(memoryLocation.end.line - 1, memoryLocation.end.column);
    locIsValid(endLoc);
    const endLine = endLoc.originalLine + 1;
    const endColumn = endLoc.originalColumn;
    (0, assert_1.default)(!Number.isNaN(endLine), `endLoc is null`);
    (0, assert_1.default)(!Number.isNaN(endColumn), `endLoc is null`);
    return {
        start: {
            line: startLine,
            column: startColumn
        },
        end: {
            line: endLine,
            column: endColumn
        }
    };
}
exports.mapToOriginalLocation = mapToOriginalLocation;
function decodeAndSetSourceMap(sourceCode, filename) {
    const lines = sourceCode.split('\n');
    let match;
    for (let i = lines.length - 10 < 0 ? 0 : lines.length - 10; i < lines.length; i++) {
        match = lines[i].match(/^\/\/# sourceMappingURL=data:application\/json;charset=utf-8;base64,(.*)$/);
        if (match)
            break;
    }
    if (!match)
        return false;
    const base64 = match[1];
    const json = Buffer.from(base64, 'base64').toString('utf8');
    const sourceMapping = JSON.parse(json);
    const decodedMappings = new node_module_1.SourceMap(sourceMapping);
    SOURCE_FILE_MAP.set(filename, decodedMappings);
    return true;
}
exports.decodeAndSetSourceMap = decodeAndSetSourceMap;
function getSourceObject(compiledSourceObject) {
    if (compiledSourceObject.loc.start.line < 0)
        return compiledSourceObject;
    let mappings = SOURCE_FILE_MAP.get(compiledSourceObject.name);
    if (!mappings)
        mappings = SOURCE_FILE_MAP.get(path_1.default.resolve(compiledSourceObject.name));
    if (mappings) {
        const loc = mapToOriginalLocation(mappings, compiledSourceObject.loc);
        if (loc.start.column === 1) {
            const contents = fs_1.default.readFileSync(compiledSourceObject.name, 'utf-8');
            const code = extractCodeSnippet(contents, loc);
            if (code.startsWith("export "))
                loc.start.column = 8;
        }
        compiledSourceObject.loc = loc;
        return compiledSourceObject;
    }
    else
        return compiledSourceObject;
}
exports.getSourceObject = getSourceObject;
function extractCodeSnippet(code, loc) {
    const lines = code.split("\n");
    const extractedLines = lines.slice(loc.start.line - 1, loc.end.line);
    if (loc.start.line === loc.end.line)
        return extractedLines[0].slice(loc.start.column - 1, loc.end.column);
    extractedLines[0] = extractedLines[0].slice(loc.start.column - 1);
    extractedLines[extractedLines.length - 1] = extractedLines[extractedLines.length - 1].slice(0, loc.end.column);
    return extractedLines.join("\n");
}
exports.extractCodeSnippet = extractCodeSnippet;
//# sourceMappingURL=sourcemaps.js.map